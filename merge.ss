(define (merge seqs)
  (define result (mlist))
  (define (loop seqs)
    (let ((nonemptySeqs (filterEmpty seqs)))
      (if (not (empty? nonemptySeqs))
          (let ((cand (findCandidate nonemptySeqs)))
            (if (not cand)
                (error "inconsistent hierarchy")
                (begin (set! result (mcons cand result))
                       (loop (removeCandidate cand nonemptySeqs))))))))
  (define (filterEmpty seqs)
    (define result (mlist))
    (define (loop seqs)
      (if (not (empty? seqs))
          (let ((head (mcar seqs))
                (tail (mcdr seqs)))
            (if (not (empty? head))
                (set! result (mcons head result)))
            (loop tail))))
    (loop seqs)
    (mreverse result))
  (define (findCandidate seqs)
    (define result false)
    (define (loop seqs)
      (if (not (empty? seqs))
          (let ((head (mcar (mcar seqs))))
            (if (elementOfTails head (mcdr seqs))
                (loop (mcdr seqs));not a good head
                (set! result head))))) ;good head
    (define (elementOfTails element seqs)
      (if (empty? seqs)
          false
          (if (mmember element (mcdr (mcar seqs)))
              true
              (elementOfTails element (mcdr seqs)))))
    (loop seqs)
    result)
  (define (removeCandidate cand seqs)
    (define result (mlist))
    (define (loop seqs)
      (if (not (empty? seqs))
          (begin
            (if (eq? (mcar (mcar seqs)) cand)
                (set! result (mcons (mcdr(mcar seqs)) result))
                (set! result (mcons (mcar seqs) result)))
            (loop (mcdr seqs)))))
    (loop seqs)
    (mreverse result))
  (loop seqs)
  (mreverse result))


